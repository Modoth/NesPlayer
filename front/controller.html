<html>
  <meta charset="utf-8" />

  <script>
    /*!
     * Socket.IO v4.5.0
     * (c) 2014-2022 Guillermo Rauch
     * Released under the MIT License.
     */
    !(function (t, e) {
      "object" == typeof exports && "undefined" != typeof module
        ? (module.exports = e())
        : "function" == typeof define && define.amd
        ? define(e)
        : ((t =
            "undefined" != typeof globalThis
              ? globalThis
              : t || self).io = e());
    })(this, function () {
      "use strict";
      function t(e) {
        return (
          (t =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t &&
                    "function" == typeof Symbol &&
                    t.constructor === Symbol &&
                    t !== Symbol.prototype
                    ? "symbol"
                    : typeof t;
                }),
          t(e)
        );
      }
      function e(t, e) {
        if (!(t instanceof e))
          throw new TypeError("Cannot call a class as a function");
      }
      function n(t, e) {
        for (var n = 0; n < e.length; n++) {
          var r = e[n];
          (r.enumerable = r.enumerable || !1),
            (r.configurable = !0),
            "value" in r && (r.writable = !0),
            Object.defineProperty(t, r.key, r);
        }
      }
      function r(t, e, r) {
        return e && n(t.prototype, e), r && n(t, r), t;
      }
      function i() {
        return (
          (i =
            Object.assign ||
            function (t) {
              for (var e = 1; e < arguments.length; e++) {
                var n = arguments[e];
                for (var r in n)
                  Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
              }
              return t;
            }),
          i.apply(this, arguments)
        );
      }
      function o(t, e) {
        if ("function" != typeof e && null !== e)
          throw new TypeError(
            "Super expression must either be null or a function"
          );
        (t.prototype = Object.create(e && e.prototype, {
          constructor: { value: t, writable: !0, configurable: !0 },
        })),
          e && a(t, e);
      }
      function s(t) {
        return (
          (s = Object.setPrototypeOf
            ? Object.getPrototypeOf
            : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t);
              }),
          s(t)
        );
      }
      function a(t, e) {
        return (
          (a =
            Object.setPrototypeOf ||
            function (t, e) {
              return (t.__proto__ = e), t;
            }),
          a(t, e)
        );
      }
      function c() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
          return (
            Boolean.prototype.valueOf.call(
              Reflect.construct(Boolean, [], function () {})
            ),
            !0
          );
        } catch (t) {
          return !1;
        }
      }
      function u(t, e, n) {
        return (
          (u = c()
            ? Reflect.construct
            : function (t, e, n) {
                var r = [null];
                r.push.apply(r, e);
                var i = new (Function.bind.apply(t, r))();
                return n && a(i, n.prototype), i;
              }),
          u.apply(null, arguments)
        );
      }
      function h(t) {
        var e = "function" == typeof Map ? new Map() : void 0;
        return (
          (h = function (t) {
            if (
              null === t ||
              ((n = t),
              -1 === Function.toString.call(n).indexOf("[native code]"))
            )
              return t;
            var n;
            if ("function" != typeof t)
              throw new TypeError(
                "Super expression must either be null or a function"
              );
            if (void 0 !== e) {
              if (e.has(t)) return e.get(t);
              e.set(t, r);
            }
            function r() {
              return u(t, arguments, s(this).constructor);
            }
            return (
              (r.prototype = Object.create(t.prototype, {
                constructor: {
                  value: r,
                  enumerable: !1,
                  writable: !0,
                  configurable: !0,
                },
              })),
              a(r, t)
            );
          }),
          h(t)
        );
      }
      function f(t) {
        if (void 0 === t)
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        return t;
      }
      function l(t, e) {
        if (e && ("object" == typeof e || "function" == typeof e)) return e;
        if (void 0 !== e)
          throw new TypeError(
            "Derived constructors may only return object or undefined"
          );
        return f(t);
      }
      function p(t) {
        var e = c();
        return function () {
          var n,
            r = s(t);
          if (e) {
            var i = s(this).constructor;
            n = Reflect.construct(r, arguments, i);
          } else n = r.apply(this, arguments);
          return l(this, n);
        };
      }
      function d(t, e, n) {
        return (
          (d =
            "undefined" != typeof Reflect && Reflect.get
              ? Reflect.get
              : function (t, e, n) {
                  var r = (function (t, e) {
                    for (
                      ;
                      !Object.prototype.hasOwnProperty.call(t, e) &&
                      null !== (t = s(t));

                    );
                    return t;
                  })(t, e);
                  if (r) {
                    var i = Object.getOwnPropertyDescriptor(r, e);
                    return i.get ? i.get.call(n) : i.value;
                  }
                }),
          d(t, e, n || t)
        );
      }
      function y(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
        return r;
      }
      function v(t, e) {
        var n =
          ("undefined" != typeof Symbol && t[Symbol.iterator]) ||
          t["@@iterator"];
        if (!n) {
          if (
            Array.isArray(t) ||
            (n = (function (t, e) {
              if (t) {
                if ("string" == typeof t) return y(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                return (
                  "Object" === n && t.constructor && (n = t.constructor.name),
                  "Map" === n || "Set" === n
                    ? Array.from(t)
                    : "Arguments" === n ||
                      /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                    ? y(t, e)
                    : void 0
                );
              }
            })(t)) ||
            (e && t && "number" == typeof t.length)
          ) {
            n && (t = n);
            var r = 0,
              i = function () {};
            return {
              s: i,
              n: function () {
                return r >= t.length
                  ? { done: !0 }
                  : { done: !1, value: t[r++] };
              },
              e: function (t) {
                throw t;
              },
              f: i,
            };
          }
          throw new TypeError(
            "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
          );
        }
        var o,
          s = !0,
          a = !1;
        return {
          s: function () {
            n = n.call(t);
          },
          n: function () {
            var t = n.next();
            return (s = t.done), t;
          },
          e: function (t) {
            (a = !0), (o = t);
          },
          f: function () {
            try {
              s || null == n.return || n.return();
            } finally {
              if (a) throw o;
            }
          },
        };
      }
      var g = Object.create(null);
      (g.open = "0"),
        (g.close = "1"),
        (g.ping = "2"),
        (g.pong = "3"),
        (g.message = "4"),
        (g.upgrade = "5"),
        (g.noop = "6");
      var m = Object.create(null);
      Object.keys(g).forEach(function (t) {
        m[g[t]] = t;
      });
      for (
        var k = { type: "error", data: "parser error" },
          b =
            "function" == typeof Blob ||
            ("undefined" != typeof Blob &&
              "[object BlobConstructor]" ===
                Object.prototype.toString.call(Blob)),
          w = "function" == typeof ArrayBuffer,
          _ = function (t, e, n) {
            var r,
              i = t.type,
              o = t.data;
            return b && o instanceof Blob
              ? e
                ? n(o)
                : A(o, n)
              : w &&
                (o instanceof ArrayBuffer ||
                  ((r = o),
                  "function" == typeof ArrayBuffer.isView
                    ? ArrayBuffer.isView(r)
                    : r && r.buffer instanceof ArrayBuffer))
              ? e
                ? n(o)
                : A(new Blob([o]), n)
              : n(g[i] + (o || ""));
          },
          A = function (t, e) {
            var n = new FileReader();
            return (
              (n.onload = function () {
                var t = n.result.split(",")[1];
                e("b" + t);
              }),
              n.readAsDataURL(t)
            );
          },
          E =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          O = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256),
          R = 0;
        R < E.length;
        R++
      )
        O[E.charCodeAt(R)] = R;
      var T = "function" == typeof ArrayBuffer,
        C = function (t, e) {
          if ("string" != typeof t) return { type: "message", data: S(t, e) };
          var n = t.charAt(0);
          return "b" === n
            ? { type: "message", data: B(t.substring(1), e) }
            : m[n]
            ? t.length > 1
              ? { type: m[n], data: t.substring(1) }
              : { type: m[n] }
            : k;
        },
        B = function (t, e) {
          if (T) {
            var n = (function (t) {
              var e,
                n,
                r,
                i,
                o,
                s = 0.75 * t.length,
                a = t.length,
                c = 0;
              "=" === t[t.length - 1] && (s--, "=" === t[t.length - 2] && s--);
              var u = new ArrayBuffer(s),
                h = new Uint8Array(u);
              for (e = 0; e < a; e += 4)
                (n = O[t.charCodeAt(e)]),
                  (r = O[t.charCodeAt(e + 1)]),
                  (i = O[t.charCodeAt(e + 2)]),
                  (o = O[t.charCodeAt(e + 3)]),
                  (h[c++] = (n << 2) | (r >> 4)),
                  (h[c++] = ((15 & r) << 4) | (i >> 2)),
                  (h[c++] = ((3 & i) << 6) | (63 & o));
              return u;
            })(t);
            return S(n, e);
          }
          return { base64: !0, data: t };
        },
        S = function (t, e) {
          return "blob" === e && t instanceof ArrayBuffer ? new Blob([t]) : t;
        },
        N = String.fromCharCode(30);
      function x(t) {
        if (t)
          return (function (t) {
            for (var e in x.prototype) t[e] = x.prototype[e];
            return t;
          })(t);
      }
      (x.prototype.on = x.prototype.addEventListener = function (t, e) {
        return (
          (this._callbacks = this._callbacks || {}),
          (this._callbacks["$" + t] = this._callbacks["$" + t] || []).push(e),
          this
        );
      }),
        (x.prototype.once = function (t, e) {
          function n() {
            this.off(t, n), e.apply(this, arguments);
          }
          return (n.fn = e), this.on(t, n), this;
        }),
        (x.prototype.off = x.prototype.removeListener = x.prototype.removeAllListeners = x.prototype.removeEventListener = function (
          t,
          e
        ) {
          if (
            ((this._callbacks = this._callbacks || {}), 0 == arguments.length)
          )
            return (this._callbacks = {}), this;
          var n,
            r = this._callbacks["$" + t];
          if (!r) return this;
          if (1 == arguments.length)
            return delete this._callbacks["$" + t], this;
          for (var i = 0; i < r.length; i++)
            if ((n = r[i]) === e || n.fn === e) {
              r.splice(i, 1);
              break;
            }
          return 0 === r.length && delete this._callbacks["$" + t], this;
        }),
        (x.prototype.emit = function (t) {
          this._callbacks = this._callbacks || {};
          for (
            var e = new Array(arguments.length - 1),
              n = this._callbacks["$" + t],
              r = 1;
            r < arguments.length;
            r++
          )
            e[r - 1] = arguments[r];
          if (n) {
            r = 0;
            for (var i = (n = n.slice(0)).length; r < i; ++r)
              n[r].apply(this, e);
          }
          return this;
        }),
        (x.prototype.emitReserved = x.prototype.emit),
        (x.prototype.listeners = function (t) {
          return (
            (this._callbacks = this._callbacks || {}),
            this._callbacks["$" + t] || []
          );
        }),
        (x.prototype.hasListeners = function (t) {
          return !!this.listeners(t).length;
        });
      var L =
        "undefined" != typeof self
          ? self
          : "undefined" != typeof window
          ? window
          : Function("return this")();
      function P(t) {
        for (
          var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1;
          r < e;
          r++
        )
          n[r - 1] = arguments[r];
        return n.reduce(function (e, n) {
          return t.hasOwnProperty(n) && (e[n] = t[n]), e;
        }, {});
      }
      var j = setTimeout,
        q = clearTimeout;
      function I(t, e) {
        e.useNativeTimers
          ? ((t.setTimeoutFn = j.bind(L)), (t.clearTimeoutFn = q.bind(L)))
          : ((t.setTimeoutFn = setTimeout.bind(L)),
            (t.clearTimeoutFn = clearTimeout.bind(L)));
      }
      var D,
        F = (function (t) {
          o(r, t);
          var n = p(r);
          function r(t, i, o) {
            var s;
            return (
              e(this, r),
              ((s = n.call(this, t)).description = i),
              (s.context = o),
              (s.type = "TransportError"),
              s
            );
          }
          return r;
        })(h(Error)),
        M = (function (t) {
          o(i, t);
          var n = p(i);
          function i(t) {
            var r;
            return (
              e(this, i),
              ((r = n.call(this)).writable = !1),
              I(f(r), t),
              (r.opts = t),
              (r.query = t.query),
              (r.readyState = ""),
              (r.socket = t.socket),
              r
            );
          }
          return (
            r(i, [
              {
                key: "onError",
                value: function (t, e, n) {
                  return (
                    d(s(i.prototype), "emitReserved", this).call(
                      this,
                      "error",
                      new F(t, e, n)
                    ),
                    this
                  );
                },
              },
              {
                key: "open",
                value: function () {
                  return (
                    ("closed" !== this.readyState && "" !== this.readyState) ||
                      ((this.readyState = "opening"), this.doOpen()),
                    this
                  );
                },
              },
              {
                key: "close",
                value: function () {
                  return (
                    ("opening" !== this.readyState &&
                      "open" !== this.readyState) ||
                      (this.doClose(), this.onClose()),
                    this
                  );
                },
              },
              {
                key: "send",
                value: function (t) {
                  "open" === this.readyState && this.write(t);
                },
              },
              {
                key: "onOpen",
                value: function () {
                  (this.readyState = "open"),
                    (this.writable = !0),
                    d(s(i.prototype), "emitReserved", this).call(this, "open");
                },
              },
              {
                key: "onData",
                value: function (t) {
                  var e = C(t, this.socket.binaryType);
                  this.onPacket(e);
                },
              },
              {
                key: "onPacket",
                value: function (t) {
                  d(s(i.prototype), "emitReserved", this).call(
                    this,
                    "packet",
                    t
                  );
                },
              },
              {
                key: "onClose",
                value: function (t) {
                  (this.readyState = "closed"),
                    d(s(i.prototype), "emitReserved", this).call(
                      this,
                      "close",
                      t
                    );
                },
              },
            ]),
            i
          );
        })(x),
        U = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(
          ""
        ),
        V = {},
        H = 0,
        K = 0;
      function Y(t) {
        var e = "";
        do {
          (e = U[t % 64] + e), (t = Math.floor(t / 64));
        } while (t > 0);
        return e;
      }
      function z() {
        var t = Y(+new Date());
        return t !== D ? ((H = 0), (D = t)) : t + "." + Y(H++);
      }
      for (; K < 64; K++) V[U[K]] = K;
      function W(t) {
        var e = "";
        for (var n in t)
          t.hasOwnProperty(n) &&
            (e.length && (e += "&"),
            (e += encodeURIComponent(n) + "=" + encodeURIComponent(t[n])));
        return e;
      }
      function $(t) {
        for (var e = {}, n = t.split("&"), r = 0, i = n.length; r < i; r++) {
          var o = n[r].split("=");
          e[decodeURIComponent(o[0])] = decodeURIComponent(o[1]);
        }
        return e;
      }
      var J = !1;
      try {
        J =
          "undefined" != typeof XMLHttpRequest &&
          "withCredentials" in new XMLHttpRequest();
      } catch (t) {}
      var X = J;
      function G(t) {
        var e = t.xdomain;
        try {
          if ("undefined" != typeof XMLHttpRequest && (!e || X))
            return new XMLHttpRequest();
        } catch (t) {}
        if (!e)
          try {
            return new L[["Active"].concat("Object").join("X")](
              "Microsoft.XMLHTTP"
            );
          } catch (t) {}
      }
      function Q() {}
      var Z = null != new G({ xdomain: !1 }).responseType,
        tt = (function (t) {
          o(s, t);
          var n = p(s);
          function s(t) {
            var r;
            if (
              (e(this, s),
              ((r = n.call(this, t)).polling = !1),
              "undefined" != typeof location)
            ) {
              var i = "https:" === location.protocol,
                o = location.port;
              o || (o = i ? "443" : "80"),
                (r.xd =
                  ("undefined" != typeof location &&
                    t.hostname !== location.hostname) ||
                  o !== t.port),
                (r.xs = t.secure !== i);
            }
            var a = t && t.forceBase64;
            return (r.supportsBinary = Z && !a), r;
          }
          return (
            r(s, [
              {
                key: "name",
                get: function () {
                  return "polling";
                },
              },
              {
                key: "doOpen",
                value: function () {
                  this.poll();
                },
              },
              {
                key: "pause",
                value: function (t) {
                  var e = this;
                  this.readyState = "pausing";
                  var n = function () {
                    (e.readyState = "paused"), t();
                  };
                  if (this.polling || !this.writable) {
                    var r = 0;
                    this.polling &&
                      (r++,
                      this.once("pollComplete", function () {
                        --r || n();
                      })),
                      this.writable ||
                        (r++,
                        this.once("drain", function () {
                          --r || n();
                        }));
                  } else n();
                },
              },
              {
                key: "poll",
                value: function () {
                  (this.polling = !0), this.doPoll(), this.emitReserved("poll");
                },
              },
              {
                key: "onData",
                value: function (t) {
                  var e = this;
                  (function (t, e) {
                    for (var n = t.split(N), r = [], i = 0; i < n.length; i++) {
                      var o = C(n[i], e);
                      if ((r.push(o), "error" === o.type)) break;
                    }
                    return r;
                  })(t, this.socket.binaryType).forEach(function (t) {
                    if (
                      ("opening" === e.readyState &&
                        "open" === t.type &&
                        e.onOpen(),
                      "close" === t.type)
                    )
                      return (
                        e.onClose({
                          description: "transport closed by the server",
                        }),
                        !1
                      );
                    e.onPacket(t);
                  }),
                    "closed" !== this.readyState &&
                      ((this.polling = !1),
                      this.emitReserved("pollComplete"),
                      "open" === this.readyState && this.poll());
                },
              },
              {
                key: "doClose",
                value: function () {
                  var t = this,
                    e = function () {
                      t.write([{ type: "close" }]);
                    };
                  "open" === this.readyState ? e() : this.once("open", e);
                },
              },
              {
                key: "write",
                value: function (t) {
                  var e = this;
                  (this.writable = !1),
                    (function (t, e) {
                      var n = t.length,
                        r = new Array(n),
                        i = 0;
                      t.forEach(function (t, o) {
                        _(t, !1, function (t) {
                          (r[o] = t), ++i === n && e(r.join(N));
                        });
                      });
                    })(t, function (t) {
                      e.doWrite(t, function () {
                        (e.writable = !0), e.emitReserved("drain");
                      });
                    });
                },
              },
              {
                key: "uri",
                value: function () {
                  var t = this.query || {},
                    e = this.opts.secure ? "https" : "http",
                    n = "";
                  !1 !== this.opts.timestampRequests &&
                    (t[this.opts.timestampParam] = z()),
                    this.supportsBinary || t.sid || (t.b64 = 1),
                    this.opts.port &&
                      (("https" === e && 443 !== Number(this.opts.port)) ||
                        ("http" === e && 80 !== Number(this.opts.port))) &&
                      (n = ":" + this.opts.port);
                  var r = W(t);
                  return (
                    e +
                    "://" +
                    (-1 !== this.opts.hostname.indexOf(":")
                      ? "[" + this.opts.hostname + "]"
                      : this.opts.hostname) +
                    n +
                    this.opts.path +
                    (r.length ? "?" + r : "")
                  );
                },
              },
              {
                key: "request",
                value: function () {
                  var t =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : {};
                  return (
                    i(t, { xd: this.xd, xs: this.xs }, this.opts),
                    new et(this.uri(), t)
                  );
                },
              },
              {
                key: "doWrite",
                value: function (t, e) {
                  var n = this,
                    r = this.request({ method: "POST", data: t });
                  r.on("success", e),
                    r.on("error", function (t, e) {
                      n.onError("xhr post error", t, e);
                    });
                },
              },
              {
                key: "doPoll",
                value: function () {
                  var t = this,
                    e = this.request();
                  e.on("data", this.onData.bind(this)),
                    e.on("error", function (e, n) {
                      t.onError("xhr poll error", e, n);
                    }),
                    (this.pollXhr = e);
                },
              },
            ]),
            s
          );
        })(M),
        et = (function (t) {
          o(i, t);
          var n = p(i);
          function i(t, r) {
            var o;
            return (
              e(this, i),
              I(f((o = n.call(this))), r),
              (o.opts = r),
              (o.method = r.method || "GET"),
              (o.uri = t),
              (o.async = !1 !== r.async),
              (o.data = void 0 !== r.data ? r.data : null),
              o.create(),
              o
            );
          }
          return (
            r(i, [
              {
                key: "create",
                value: function () {
                  var t = this,
                    e = P(
                      this.opts,
                      "agent",
                      "pfx",
                      "key",
                      "passphrase",
                      "cert",
                      "ca",
                      "ciphers",
                      "rejectUnauthorized",
                      "autoUnref"
                    );
                  (e.xdomain = !!this.opts.xd), (e.xscheme = !!this.opts.xs);
                  var n = (this.xhr = new G(e));
                  try {
                    n.open(this.method, this.uri, this.async);
                    try {
                      if (this.opts.extraHeaders)
                        for (var r in (n.setDisableHeaderCheck &&
                          n.setDisableHeaderCheck(!0),
                        this.opts.extraHeaders))
                          this.opts.extraHeaders.hasOwnProperty(r) &&
                            n.setRequestHeader(r, this.opts.extraHeaders[r]);
                    } catch (t) {}
                    if ("POST" === this.method)
                      try {
                        n.setRequestHeader(
                          "Content-type",
                          "text/plain;charset=UTF-8"
                        );
                      } catch (t) {}
                    try {
                      n.setRequestHeader("Accept", "*/*");
                    } catch (t) {}
                    "withCredentials" in n &&
                      (n.withCredentials = this.opts.withCredentials),
                      this.opts.requestTimeout &&
                        (n.timeout = this.opts.requestTimeout),
                      (n.onreadystatechange = function () {
                        4 === n.readyState &&
                          (200 === n.status || 1223 === n.status
                            ? t.onLoad()
                            : t.setTimeoutFn(function () {
                                t.onError(
                                  "number" == typeof n.status ? n.status : 0
                                );
                              }, 0));
                      }),
                      n.send(this.data);
                  } catch (e) {
                    return void this.setTimeoutFn(function () {
                      t.onError(e);
                    }, 0);
                  }
                  "undefined" != typeof document &&
                    ((this.index = i.requestsCount++),
                    (i.requests[this.index] = this));
                },
              },
              {
                key: "onError",
                value: function (t) {
                  this.emitReserved("error", t, this.xhr), this.cleanup(!0);
                },
              },
              {
                key: "cleanup",
                value: function (t) {
                  if (void 0 !== this.xhr && null !== this.xhr) {
                    if (((this.xhr.onreadystatechange = Q), t))
                      try {
                        this.xhr.abort();
                      } catch (t) {}
                    "undefined" != typeof document &&
                      delete i.requests[this.index],
                      (this.xhr = null);
                  }
                },
              },
              {
                key: "onLoad",
                value: function () {
                  var t = this.xhr.responseText;
                  null !== t &&
                    (this.emitReserved("data", t),
                    this.emitReserved("success"),
                    this.cleanup());
                },
              },
              {
                key: "abort",
                value: function () {
                  this.cleanup();
                },
              },
            ]),
            i
          );
        })(x);
      if (
        ((et.requestsCount = 0),
        (et.requests = {}),
        "undefined" != typeof document)
      )
        if ("function" == typeof attachEvent) attachEvent("onunload", nt);
        else if ("function" == typeof addEventListener) {
          addEventListener("onpagehide" in L ? "pagehide" : "unload", nt, !1);
        }
      function nt() {
        for (var t in et.requests)
          et.requests.hasOwnProperty(t) && et.requests[t].abort();
      }
      var rt =
          "function" == typeof Promise && "function" == typeof Promise.resolve
            ? function (t) {
                return Promise.resolve().then(t);
              }
            : function (t, e) {
                return e(t, 0);
              },
        it = L.WebSocket || L.MozWebSocket,
        ot =
          "undefined" != typeof navigator &&
          "string" == typeof navigator.product &&
          "reactnative" === navigator.product.toLowerCase(),
        st = (function (t) {
          o(i, t);
          var n = p(i);
          function i(t) {
            var r;
            return (
              e(this, i),
              ((r = n.call(this, t)).supportsBinary = !t.forceBase64),
              r
            );
          }
          return (
            r(i, [
              {
                key: "name",
                get: function () {
                  return "websocket";
                },
              },
              {
                key: "doOpen",
                value: function () {
                  if (this.check()) {
                    var t = this.uri(),
                      e = this.opts.protocols,
                      n = ot
                        ? {}
                        : P(
                            this.opts,
                            "agent",
                            "perMessageDeflate",
                            "pfx",
                            "key",
                            "passphrase",
                            "cert",
                            "ca",
                            "ciphers",
                            "rejectUnauthorized",
                            "localAddress",
                            "protocolVersion",
                            "origin",
                            "maxPayload",
                            "family",
                            "checkServerIdentity"
                          );
                    this.opts.extraHeaders &&
                      (n.headers = this.opts.extraHeaders);
                    try {
                      this.ws = ot
                        ? new it(t, e, n)
                        : e
                        ? new it(t, e)
                        : new it(t);
                    } catch (t) {
                      return this.emitReserved("error", t);
                    }
                    (this.ws.binaryType =
                      this.socket.binaryType || "arraybuffer"),
                      this.addEventListeners();
                  }
                },
              },
              {
                key: "addEventListeners",
                value: function () {
                  var t = this;
                  (this.ws.onopen = function () {
                    t.opts.autoUnref && t.ws._socket.unref(), t.onOpen();
                  }),
                    (this.ws.onclose = function (e) {
                      return t.onClose({
                        description: "websocket connection closed",
                        context: e,
                      });
                    }),
                    (this.ws.onmessage = function (e) {
                      return t.onData(e.data);
                    }),
                    (this.ws.onerror = function (e) {
                      return t.onError("websocket error", e);
                    });
                },
              },
              {
                key: "write",
                value: function (t) {
                  var e = this;
                  this.writable = !1;
                  for (
                    var n = function (n) {
                        var r = t[n],
                          i = n === t.length - 1;
                        _(r, e.supportsBinary, function (t) {
                          try {
                            e.ws.send(t);
                          } catch (t) {}
                          i &&
                            rt(function () {
                              (e.writable = !0), e.emitReserved("drain");
                            }, e.setTimeoutFn);
                        });
                      },
                      r = 0;
                    r < t.length;
                    r++
                  )
                    n(r);
                },
              },
              {
                key: "doClose",
                value: function () {
                  void 0 !== this.ws && (this.ws.close(), (this.ws = null));
                },
              },
              {
                key: "uri",
                value: function () {
                  var t = this.query || {},
                    e = this.opts.secure ? "wss" : "ws",
                    n = "";
                  this.opts.port &&
                    (("wss" === e && 443 !== Number(this.opts.port)) ||
                      ("ws" === e && 80 !== Number(this.opts.port))) &&
                    (n = ":" + this.opts.port),
                    this.opts.timestampRequests &&
                      (t[this.opts.timestampParam] = z()),
                    this.supportsBinary || (t.b64 = 1);
                  var r = W(t);
                  return (
                    e +
                    "://" +
                    (-1 !== this.opts.hostname.indexOf(":")
                      ? "[" + this.opts.hostname + "]"
                      : this.opts.hostname) +
                    n +
                    this.opts.path +
                    (r.length ? "?" + r : "")
                  );
                },
              },
              {
                key: "check",
                value: function () {
                  return !(
                    !it ||
                    ("__initialize" in it && this.name === i.prototype.name)
                  );
                },
              },
            ]),
            i
          );
        })(M),
        at = { websocket: st, polling: tt },
        ct = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
        ut = [
          "source",
          "protocol",
          "authority",
          "userInfo",
          "user",
          "password",
          "host",
          "port",
          "relative",
          "path",
          "directory",
          "file",
          "query",
          "anchor",
        ];
      function ht(t) {
        var e = t,
          n = t.indexOf("["),
          r = t.indexOf("]");
        -1 != n &&
          -1 != r &&
          (t =
            t.substring(0, n) +
            t.substring(n, r).replace(/:/g, ";") +
            t.substring(r, t.length));
        for (var i, o, s = ct.exec(t || ""), a = {}, c = 14; c--; )
          a[ut[c]] = s[c] || "";
        return (
          -1 != n &&
            -1 != r &&
            ((a.source = e),
            (a.host = a.host
              .substring(1, a.host.length - 1)
              .replace(/;/g, ":")),
            (a.authority = a.authority
              .replace("[", "")
              .replace("]", "")
              .replace(/;/g, ":")),
            (a.ipv6uri = !0)),
          (a.pathNames = (function (t, e) {
            var n = /\/{2,9}/g,
              r = e.replace(n, "/").split("/");
            ("/" != e.substr(0, 1) && 0 !== e.length) || r.splice(0, 1);
            "/" == e.substr(e.length - 1, 1) && r.splice(r.length - 1, 1);
            return r;
          })(0, a.path)),
          (a.queryKey =
            ((i = a.query),
            (o = {}),
            i.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (t, e, n) {
              e && (o[e] = n);
            }),
            o)),
          a
        );
      }
      var ft = (function (n) {
        o(a, n);
        var s = p(a);
        function a(n) {
          var r,
            o =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {};
          return (
            e(this, a),
            (r = s.call(this)),
            n && "object" === t(n) && ((o = n), (n = null)),
            n
              ? ((n = ht(n)),
                (o.hostname = n.host),
                (o.secure = "https" === n.protocol || "wss" === n.protocol),
                (o.port = n.port),
                n.query && (o.query = n.query))
              : o.host && (o.hostname = ht(o.host).host),
            I(f(r), o),
            (r.secure =
              null != o.secure
                ? o.secure
                : "undefined" != typeof location &&
                  "https:" === location.protocol),
            o.hostname && !o.port && (o.port = r.secure ? "443" : "80"),
            (r.hostname =
              o.hostname ||
              ("undefined" != typeof location
                ? location.hostname
                : "localhost")),
            (r.port =
              o.port ||
              ("undefined" != typeof location && location.port
                ? location.port
                : r.secure
                ? "443"
                : "80")),
            (r.transports = o.transports || ["polling", "websocket"]),
            (r.readyState = ""),
            (r.writeBuffer = []),
            (r.prevBufferLen = 0),
            (r.opts = i(
              {
                path: "/engine.io",
                agent: !1,
                withCredentials: !1,
                upgrade: !0,
                timestampParam: "t",
                rememberUpgrade: !1,
                rejectUnauthorized: !0,
                perMessageDeflate: { threshold: 1024 },
                transportOptions: {},
                closeOnBeforeunload: !0,
              },
              o
            )),
            (r.opts.path = r.opts.path.replace(/\/$/, "") + "/"),
            "string" == typeof r.opts.query && (r.opts.query = $(r.opts.query)),
            (r.id = null),
            (r.upgrades = null),
            (r.pingInterval = null),
            (r.pingTimeout = null),
            (r.pingTimeoutTimer = null),
            "function" == typeof addEventListener &&
              (r.opts.closeOnBeforeunload &&
                addEventListener(
                  "beforeunload",
                  function () {
                    r.transport &&
                      (r.transport.removeAllListeners(), r.transport.close());
                  },
                  !1
                ),
              "localhost" !== r.hostname &&
                ((r.offlineEventListener = function () {
                  r.onClose("transport close", {
                    description: "network connection lost",
                  });
                }),
                addEventListener("offline", r.offlineEventListener, !1))),
            r.open(),
            r
          );
        }
        return (
          r(a, [
            {
              key: "createTransport",
              value: function (t) {
                var e = i({}, this.opts.query);
                (e.EIO = 4), (e.transport = t), this.id && (e.sid = this.id);
                var n = i({}, this.opts.transportOptions[t], this.opts, {
                  query: e,
                  socket: this,
                  hostname: this.hostname,
                  secure: this.secure,
                  port: this.port,
                });
                return new at[t](n);
              },
            },
            {
              key: "open",
              value: function () {
                var t,
                  e = this;
                if (
                  this.opts.rememberUpgrade &&
                  a.priorWebsocketSuccess &&
                  -1 !== this.transports.indexOf("websocket")
                )
                  t = "websocket";
                else {
                  if (0 === this.transports.length)
                    return void this.setTimeoutFn(function () {
                      e.emitReserved("error", "No transports available");
                    }, 0);
                  t = this.transports[0];
                }
                this.readyState = "opening";
                try {
                  t = this.createTransport(t);
                } catch (t) {
                  return this.transports.shift(), void this.open();
                }
                t.open(), this.setTransport(t);
              },
            },
            {
              key: "setTransport",
              value: function (t) {
                var e = this;
                this.transport && this.transport.removeAllListeners(),
                  (this.transport = t),
                  t
                    .on("drain", this.onDrain.bind(this))
                    .on("packet", this.onPacket.bind(this))
                    .on("error", this.onError.bind(this))
                    .on("close", function (t) {
                      return e.onClose("transport close", t);
                    });
              },
            },
            {
              key: "probe",
              value: function (t) {
                var e = this,
                  n = this.createTransport(t),
                  r = !1;
                a.priorWebsocketSuccess = !1;
                var i = function () {
                  r ||
                    (n.send([{ type: "ping", data: "probe" }]),
                    n.once("packet", function (t) {
                      if (!r)
                        if ("pong" === t.type && "probe" === t.data) {
                          if (
                            ((e.upgrading = !0),
                            e.emitReserved("upgrading", n),
                            !n)
                          )
                            return;
                          (a.priorWebsocketSuccess = "websocket" === n.name),
                            e.transport.pause(function () {
                              r ||
                                ("closed" !== e.readyState &&
                                  (f(),
                                  e.setTransport(n),
                                  n.send([{ type: "upgrade" }]),
                                  e.emitReserved("upgrade", n),
                                  (n = null),
                                  (e.upgrading = !1),
                                  e.flush()));
                            });
                        } else {
                          var i = new Error("probe error");
                          (i.transport = n.name),
                            e.emitReserved("upgradeError", i);
                        }
                    }));
                };
                function o() {
                  r || ((r = !0), f(), n.close(), (n = null));
                }
                var s = function (t) {
                  var r = new Error("probe error: " + t);
                  (r.transport = n.name),
                    o(),
                    e.emitReserved("upgradeError", r);
                };
                function c() {
                  s("transport closed");
                }
                function u() {
                  s("socket closed");
                }
                function h(t) {
                  n && t.name !== n.name && o();
                }
                var f = function () {
                  n.removeListener("open", i),
                    n.removeListener("error", s),
                    n.removeListener("close", c),
                    e.off("close", u),
                    e.off("upgrading", h);
                };
                n.once("open", i),
                  n.once("error", s),
                  n.once("close", c),
                  this.once("close", u),
                  this.once("upgrading", h),
                  n.open();
              },
            },
            {
              key: "onOpen",
              value: function () {
                if (
                  ((this.readyState = "open"),
                  (a.priorWebsocketSuccess =
                    "websocket" === this.transport.name),
                  this.emitReserved("open"),
                  this.flush(),
                  "open" === this.readyState &&
                    this.opts.upgrade &&
                    this.transport.pause)
                )
                  for (var t = 0, e = this.upgrades.length; t < e; t++)
                    this.probe(this.upgrades[t]);
              },
            },
            {
              key: "onPacket",
              value: function (t) {
                if (
                  "opening" === this.readyState ||
                  "open" === this.readyState ||
                  "closing" === this.readyState
                )
                  switch (
                    (this.emitReserved("packet", t),
                    this.emitReserved("heartbeat"),
                    t.type)
                  ) {
                    case "open":
                      this.onHandshake(JSON.parse(t.data));
                      break;
                    case "ping":
                      this.resetPingTimeout(),
                        this.sendPacket("pong"),
                        this.emitReserved("ping"),
                        this.emitReserved("pong");
                      break;
                    case "error":
                      var e = new Error("server error");
                      (e.code = t.data), this.onError(e);
                      break;
                    case "message":
                      this.emitReserved("data", t.data),
                        this.emitReserved("message", t.data);
                  }
              },
            },
            {
              key: "onHandshake",
              value: function (t) {
                this.emitReserved("handshake", t),
                  (this.id = t.sid),
                  (this.transport.query.sid = t.sid),
                  (this.upgrades = this.filterUpgrades(t.upgrades)),
                  (this.pingInterval = t.pingInterval),
                  (this.pingTimeout = t.pingTimeout),
                  (this.maxPayload = t.maxPayload),
                  this.onOpen(),
                  "closed" !== this.readyState && this.resetPingTimeout();
              },
            },
            {
              key: "resetPingTimeout",
              value: function () {
                var t = this;
                this.clearTimeoutFn(this.pingTimeoutTimer),
                  (this.pingTimeoutTimer = this.setTimeoutFn(function () {
                    t.onClose("ping timeout");
                  }, this.pingInterval + this.pingTimeout)),
                  this.opts.autoUnref && this.pingTimeoutTimer.unref();
              },
            },
            {
              key: "onDrain",
              value: function () {
                this.writeBuffer.splice(0, this.prevBufferLen),
                  (this.prevBufferLen = 0),
                  0 === this.writeBuffer.length
                    ? this.emitReserved("drain")
                    : this.flush();
              },
            },
            {
              key: "flush",
              value: function () {
                if (
                  "closed" !== this.readyState &&
                  this.transport.writable &&
                  !this.upgrading &&
                  this.writeBuffer.length
                ) {
                  var t = this.getWritablePackets();
                  this.transport.send(t),
                    (this.prevBufferLen = t.length),
                    this.emitReserved("flush");
                }
              },
            },
            {
              key: "getWritablePackets",
              value: function () {
                if (
                  !(
                    this.maxPayload &&
                    "polling" === this.transport.name &&
                    this.writeBuffer.length > 1
                  )
                )
                  return this.writeBuffer;
                for (var t, e = 1, n = 0; n < this.writeBuffer.length; n++) {
                  var r = this.writeBuffer[n].data;
                  if (
                    (r &&
                      (e +=
                        "string" == typeof (t = r)
                          ? (function (t) {
                              for (
                                var e = 0, n = 0, r = 0, i = t.length;
                                r < i;
                                r++
                              )
                                (e = t.charCodeAt(r)) < 128
                                  ? (n += 1)
                                  : e < 2048
                                  ? (n += 2)
                                  : e < 55296 || e >= 57344
                                  ? (n += 3)
                                  : (r++, (n += 4));
                              return n;
                            })(t)
                          : Math.ceil(1.33 * (t.byteLength || t.size))),
                    n > 0 && e > this.maxPayload)
                  )
                    return this.writeBuffer.slice(0, n);
                  e += 2;
                }
                return this.writeBuffer;
              },
            },
            {
              key: "write",
              value: function (t, e, n) {
                return this.sendPacket("message", t, e, n), this;
              },
            },
            {
              key: "send",
              value: function (t, e, n) {
                return this.sendPacket("message", t, e, n), this;
              },
            },
            {
              key: "sendPacket",
              value: function (t, e, n, r) {
                if (
                  ("function" == typeof e && ((r = e), (e = void 0)),
                  "function" == typeof n && ((r = n), (n = null)),
                  "closing" !== this.readyState && "closed" !== this.readyState)
                ) {
                  (n = n || {}).compress = !1 !== n.compress;
                  var i = { type: t, data: e, options: n };
                  this.emitReserved("packetCreate", i),
                    this.writeBuffer.push(i),
                    r && this.once("flush", r),
                    this.flush();
                }
              },
            },
            {
              key: "close",
              value: function () {
                var t = this,
                  e = function () {
                    t.onClose("forced close"), t.transport.close();
                  },
                  n = function n() {
                    t.off("upgrade", n), t.off("upgradeError", n), e();
                  },
                  r = function () {
                    t.once("upgrade", n), t.once("upgradeError", n);
                  };
                return (
                  ("opening" !== this.readyState &&
                    "open" !== this.readyState) ||
                    ((this.readyState = "closing"),
                    this.writeBuffer.length
                      ? this.once("drain", function () {
                          t.upgrading ? r() : e();
                        })
                      : this.upgrading
                      ? r()
                      : e()),
                  this
                );
              },
            },
            {
              key: "onError",
              value: function (t) {
                (a.priorWebsocketSuccess = !1),
                  this.emitReserved("error", t),
                  this.onClose("transport error", t);
              },
            },
            {
              key: "onClose",
              value: function (t, e) {
                ("opening" !== this.readyState &&
                  "open" !== this.readyState &&
                  "closing" !== this.readyState) ||
                  (this.clearTimeoutFn(this.pingTimeoutTimer),
                  this.transport.removeAllListeners("close"),
                  this.transport.close(),
                  this.transport.removeAllListeners(),
                  "function" == typeof removeEventListener &&
                    removeEventListener(
                      "offline",
                      this.offlineEventListener,
                      !1
                    ),
                  (this.readyState = "closed"),
                  (this.id = null),
                  this.emitReserved("close", t, e),
                  (this.writeBuffer = []),
                  (this.prevBufferLen = 0));
              },
            },
            {
              key: "filterUpgrades",
              value: function (t) {
                for (var e = [], n = 0, r = t.length; n < r; n++)
                  ~this.transports.indexOf(t[n]) && e.push(t[n]);
                return e;
              },
            },
          ]),
          a
        );
      })(x);
      ft.protocol = 4;
      var lt = "function" == typeof ArrayBuffer,
        pt = Object.prototype.toString,
        dt =
          "function" == typeof Blob ||
          ("undefined" != typeof Blob &&
            "[object BlobConstructor]" === pt.call(Blob)),
        yt =
          "function" == typeof File ||
          ("undefined" != typeof File &&
            "[object FileConstructor]" === pt.call(File));
      function vt(t) {
        return (
          (lt &&
            (t instanceof ArrayBuffer ||
              (function (t) {
                return "function" == typeof ArrayBuffer.isView
                  ? ArrayBuffer.isView(t)
                  : t.buffer instanceof ArrayBuffer;
              })(t))) ||
          (dt && t instanceof Blob) ||
          (yt && t instanceof File)
        );
      }
      function gt(e, n) {
        if (!e || "object" !== t(e)) return !1;
        if (Array.isArray(e)) {
          for (var r = 0, i = e.length; r < i; r++) if (gt(e[r])) return !0;
          return !1;
        }
        if (vt(e)) return !0;
        if (e.toJSON && "function" == typeof e.toJSON && 1 === arguments.length)
          return gt(e.toJSON(), !0);
        for (var o in e)
          if (Object.prototype.hasOwnProperty.call(e, o) && gt(e[o])) return !0;
        return !1;
      }
      function mt(t) {
        var e = [],
          n = t.data,
          r = t;
        return (
          (r.data = kt(n, e)),
          (r.attachments = e.length),
          { packet: r, buffers: e }
        );
      }
      function kt(e, n) {
        if (!e) return e;
        if (vt(e)) {
          var r = { _placeholder: !0, num: n.length };
          return n.push(e), r;
        }
        if (Array.isArray(e)) {
          for (var i = new Array(e.length), o = 0; o < e.length; o++)
            i[o] = kt(e[o], n);
          return i;
        }
        if ("object" === t(e) && !(e instanceof Date)) {
          var s = {};
          for (var a in e)
            Object.prototype.hasOwnProperty.call(e, a) && (s[a] = kt(e[a], n));
          return s;
        }
        return e;
      }
      function bt(t, e) {
        return (t.data = wt(t.data, e)), (t.attachments = void 0), t;
      }
      function wt(e, n) {
        if (!e) return e;
        if (e && e._placeholder) return n[e.num];
        if (Array.isArray(e))
          for (var r = 0; r < e.length; r++) e[r] = wt(e[r], n);
        else if ("object" === t(e))
          for (var i in e)
            Object.prototype.hasOwnProperty.call(e, i) && (e[i] = wt(e[i], n));
        return e;
      }
      var _t;
      !(function (t) {
        (t[(t.CONNECT = 0)] = "CONNECT"),
          (t[(t.DISCONNECT = 1)] = "DISCONNECT"),
          (t[(t.EVENT = 2)] = "EVENT"),
          (t[(t.ACK = 3)] = "ACK"),
          (t[(t.CONNECT_ERROR = 4)] = "CONNECT_ERROR"),
          (t[(t.BINARY_EVENT = 5)] = "BINARY_EVENT"),
          (t[(t.BINARY_ACK = 6)] = "BINARY_ACK");
      })(_t || (_t = {}));
      var At = (function () {
          function t(n) {
            e(this, t), (this.replacer = n);
          }
          return (
            r(t, [
              {
                key: "encode",
                value: function (t) {
                  return (t.type !== _t.EVENT && t.type !== _t.ACK) || !gt(t)
                    ? [this.encodeAsString(t)]
                    : ((t.type =
                        t.type === _t.EVENT ? _t.BINARY_EVENT : _t.BINARY_ACK),
                      this.encodeAsBinary(t));
                },
              },
              {
                key: "encodeAsString",
                value: function (t) {
                  var e = "" + t.type;
                  return (
                    (t.type !== _t.BINARY_EVENT && t.type !== _t.BINARY_ACK) ||
                      (e += t.attachments + "-"),
                    t.nsp && "/" !== t.nsp && (e += t.nsp + ","),
                    null != t.id && (e += t.id),
                    null != t.data &&
                      (e += JSON.stringify(t.data, this.replacer)),
                    e
                  );
                },
              },
              {
                key: "encodeAsBinary",
                value: function (t) {
                  var e = mt(t),
                    n = this.encodeAsString(e.packet),
                    r = e.buffers;
                  return r.unshift(n), r;
                },
              },
            ]),
            t
          );
        })(),
        Et = (function (n) {
          o(a, n);
          var i = p(a);
          function a(t) {
            var n;
            return e(this, a), ((n = i.call(this)).reviver = t), n;
          }
          return (
            r(
              a,
              [
                {
                  key: "add",
                  value: function (t) {
                    var e;
                    if ("string" == typeof t)
                      (e = this.decodeString(t)).type === _t.BINARY_EVENT ||
                      e.type === _t.BINARY_ACK
                        ? ((this.reconstructor = new Ot(e)),
                          0 === e.attachments &&
                            d(s(a.prototype), "emitReserved", this).call(
                              this,
                              "decoded",
                              e
                            ))
                        : d(s(a.prototype), "emitReserved", this).call(
                            this,
                            "decoded",
                            e
                          );
                    else {
                      if (!vt(t) && !t.base64)
                        throw new Error("Unknown type: " + t);
                      if (!this.reconstructor)
                        throw new Error(
                          "got binary data when not reconstructing a packet"
                        );
                      (e = this.reconstructor.takeBinaryData(t)) &&
                        ((this.reconstructor = null),
                        d(s(a.prototype), "emitReserved", this).call(
                          this,
                          "decoded",
                          e
                        ));
                    }
                  },
                },
                {
                  key: "decodeString",
                  value: function (t) {
                    var e = 0,
                      n = { type: Number(t.charAt(0)) };
                    if (void 0 === _t[n.type])
                      throw new Error("unknown packet type " + n.type);
                    if (
                      n.type === _t.BINARY_EVENT ||
                      n.type === _t.BINARY_ACK
                    ) {
                      for (
                        var r = e + 1;
                        "-" !== t.charAt(++e) && e != t.length;

                      );
                      var i = t.substring(r, e);
                      if (i != Number(i) || "-" !== t.charAt(e))
                        throw new Error("Illegal attachments");
                      n.attachments = Number(i);
                    }
                    if ("/" === t.charAt(e + 1)) {
                      for (var o = e + 1; ++e; ) {
                        if ("," === t.charAt(e)) break;
                        if (e === t.length) break;
                      }
                      n.nsp = t.substring(o, e);
                    } else n.nsp = "/";
                    var s = t.charAt(e + 1);
                    if ("" !== s && Number(s) == s) {
                      for (var c = e + 1; ++e; ) {
                        var u = t.charAt(e);
                        if (null == u || Number(u) != u) {
                          --e;
                          break;
                        }
                        if (e === t.length) break;
                      }
                      n.id = Number(t.substring(c, e + 1));
                    }
                    if (t.charAt(++e)) {
                      var h = this.tryParse(t.substr(e));
                      if (!a.isPayloadValid(n.type, h))
                        throw new Error("invalid payload");
                      n.data = h;
                    }
                    return n;
                  },
                },
                {
                  key: "tryParse",
                  value: function (t) {
                    try {
                      return JSON.parse(t, this.reviver);
                    } catch (t) {
                      return !1;
                    }
                  },
                },
                {
                  key: "destroy",
                  value: function () {
                    this.reconstructor &&
                      this.reconstructor.finishedReconstruction();
                  },
                },
              ],
              [
                {
                  key: "isPayloadValid",
                  value: function (e, n) {
                    switch (e) {
                      case _t.CONNECT:
                        return "object" === t(n);
                      case _t.DISCONNECT:
                        return void 0 === n;
                      case _t.CONNECT_ERROR:
                        return "string" == typeof n || "object" === t(n);
                      case _t.EVENT:
                      case _t.BINARY_EVENT:
                        return Array.isArray(n) && n.length > 0;
                      case _t.ACK:
                      case _t.BINARY_ACK:
                        return Array.isArray(n);
                    }
                  },
                },
              ]
            ),
            a
          );
        })(x),
        Ot = (function () {
          function t(n) {
            e(this, t),
              (this.packet = n),
              (this.buffers = []),
              (this.reconPack = n);
          }
          return (
            r(t, [
              {
                key: "takeBinaryData",
                value: function (t) {
                  if (
                    (this.buffers.push(t),
                    this.buffers.length === this.reconPack.attachments)
                  ) {
                    var e = bt(this.reconPack, this.buffers);
                    return this.finishedReconstruction(), e;
                  }
                  return null;
                },
              },
              {
                key: "finishedReconstruction",
                value: function () {
                  (this.reconPack = null), (this.buffers = []);
                },
              },
            ]),
            t
          );
        })(),
        Rt = Object.freeze({
          __proto__: null,
          protocol: 5,
          get PacketType() {
            return _t;
          },
          Encoder: At,
          Decoder: Et,
        });
      function Tt(t, e, n) {
        return (
          t.on(e, n),
          function () {
            t.off(e, n);
          }
        );
      }
      var Ct = Object.freeze({
          connect: 1,
          connect_error: 1,
          disconnect: 1,
          disconnecting: 1,
          newListener: 1,
          removeListener: 1,
        }),
        Bt = (function (t) {
          o(i, t);
          var n = p(i);
          function i(t, r, o) {
            var s;
            return (
              e(this, i),
              ((s = n.call(this)).connected = !1),
              (s.receiveBuffer = []),
              (s.sendBuffer = []),
              (s.ids = 0),
              (s.acks = {}),
              (s.flags = {}),
              (s.io = t),
              (s.nsp = r),
              o && o.auth && (s.auth = o.auth),
              s.io._autoConnect && s.open(),
              s
            );
          }
          return (
            r(i, [
              {
                key: "disconnected",
                get: function () {
                  return !this.connected;
                },
              },
              {
                key: "subEvents",
                value: function () {
                  if (!this.subs) {
                    var t = this.io;
                    this.subs = [
                      Tt(t, "open", this.onopen.bind(this)),
                      Tt(t, "packet", this.onpacket.bind(this)),
                      Tt(t, "error", this.onerror.bind(this)),
                      Tt(t, "close", this.onclose.bind(this)),
                    ];
                  }
                },
              },
              {
                key: "active",
                get: function () {
                  return !!this.subs;
                },
              },
              {
                key: "connect",
                value: function () {
                  return (
                    this.connected ||
                      (this.subEvents(),
                      this.io._reconnecting || this.io.open(),
                      "open" === this.io._readyState && this.onopen()),
                    this
                  );
                },
              },
              {
                key: "open",
                value: function () {
                  return this.connect();
                },
              },
              {
                key: "send",
                value: function () {
                  for (
                    var t = arguments.length, e = new Array(t), n = 0;
                    n < t;
                    n++
                  )
                    e[n] = arguments[n];
                  return e.unshift("message"), this.emit.apply(this, e), this;
                },
              },
              {
                key: "emit",
                value: function (t) {
                  if (Ct.hasOwnProperty(t))
                    throw new Error('"' + t + '" is a reserved event name');
                  for (
                    var e = arguments.length,
                      n = new Array(e > 1 ? e - 1 : 0),
                      r = 1;
                    r < e;
                    r++
                  )
                    n[r - 1] = arguments[r];
                  n.unshift(t);
                  var i = { type: _t.EVENT, data: n, options: {} };
                  if (
                    ((i.options.compress = !1 !== this.flags.compress),
                    "function" == typeof n[n.length - 1])
                  ) {
                    var o = this.ids++,
                      s = n.pop();
                    this._registerAckCallback(o, s), (i.id = o);
                  }
                  var a =
                      this.io.engine &&
                      this.io.engine.transport &&
                      this.io.engine.transport.writable,
                    c = this.flags.volatile && (!a || !this.connected);
                  return (
                    c ||
                      (this.connected
                        ? (this.notifyOutgoingListeners(i), this.packet(i))
                        : this.sendBuffer.push(i)),
                    (this.flags = {}),
                    this
                  );
                },
              },
              {
                key: "_registerAckCallback",
                value: function (t, e) {
                  var n = this,
                    r = this.flags.timeout;
                  if (void 0 !== r) {
                    var i = this.io.setTimeoutFn(function () {
                      delete n.acks[t];
                      for (var r = 0; r < n.sendBuffer.length; r++)
                        n.sendBuffer[r].id === t && n.sendBuffer.splice(r, 1);
                      e.call(n, new Error("operation has timed out"));
                    }, r);
                    this.acks[t] = function () {
                      n.io.clearTimeoutFn(i);
                      for (
                        var t = arguments.length, r = new Array(t), o = 0;
                        o < t;
                        o++
                      )
                        r[o] = arguments[o];
                      e.apply(n, [null].concat(r));
                    };
                  } else this.acks[t] = e;
                },
              },
              {
                key: "packet",
                value: function (t) {
                  (t.nsp = this.nsp), this.io._packet(t);
                },
              },
              {
                key: "onopen",
                value: function () {
                  var t = this;
                  "function" == typeof this.auth
                    ? this.auth(function (e) {
                        t.packet({ type: _t.CONNECT, data: e });
                      })
                    : this.packet({ type: _t.CONNECT, data: this.auth });
                },
              },
              {
                key: "onerror",
                value: function (t) {
                  this.connected || this.emitReserved("connect_error", t);
                },
              },
              {
                key: "onclose",
                value: function (t, e) {
                  (this.connected = !1),
                    delete this.id,
                    this.emitReserved("disconnect", t, e);
                },
              },
              {
                key: "onpacket",
                value: function (t) {
                  if (t.nsp === this.nsp)
                    switch (t.type) {
                      case _t.CONNECT:
                        if (t.data && t.data.sid) {
                          var e = t.data.sid;
                          this.onconnect(e);
                        } else
                          this.emitReserved(
                            "connect_error",
                            new Error(
                              "It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"
                            )
                          );
                        break;
                      case _t.EVENT:
                      case _t.BINARY_EVENT:
                        this.onevent(t);
                        break;
                      case _t.ACK:
                      case _t.BINARY_ACK:
                        this.onack(t);
                        break;
                      case _t.DISCONNECT:
                        this.ondisconnect();
                        break;
                      case _t.CONNECT_ERROR:
                        this.destroy();
                        var n = new Error(t.data.message);
                        (n.data = t.data.data),
                          this.emitReserved("connect_error", n);
                    }
                },
              },
              {
                key: "onevent",
                value: function (t) {
                  var e = t.data || [];
                  null != t.id && e.push(this.ack(t.id)),
                    this.connected
                      ? this.emitEvent(e)
                      : this.receiveBuffer.push(Object.freeze(e));
                },
              },
              {
                key: "emitEvent",
                value: function (t) {
                  if (this._anyListeners && this._anyListeners.length) {
                    var e,
                      n = v(this._anyListeners.slice());
                    try {
                      for (n.s(); !(e = n.n()).done; ) {
                        e.value.apply(this, t);
                      }
                    } catch (t) {
                      n.e(t);
                    } finally {
                      n.f();
                    }
                  }
                  d(s(i.prototype), "emit", this).apply(this, t);
                },
              },
              {
                key: "ack",
                value: function (t) {
                  var e = this,
                    n = !1;
                  return function () {
                    if (!n) {
                      n = !0;
                      for (
                        var r = arguments.length, i = new Array(r), o = 0;
                        o < r;
                        o++
                      )
                        i[o] = arguments[o];
                      e.packet({ type: _t.ACK, id: t, data: i });
                    }
                  };
                },
              },
              {
                key: "onack",
                value: function (t) {
                  var e = this.acks[t.id];
                  "function" == typeof e &&
                    (e.apply(this, t.data), delete this.acks[t.id]);
                },
              },
              {
                key: "onconnect",
                value: function (t) {
                  (this.id = t),
                    (this.connected = !0),
                    this.emitBuffered(),
                    this.emitReserved("connect");
                },
              },
              {
                key: "emitBuffered",
                value: function () {
                  var t = this;
                  this.receiveBuffer.forEach(function (e) {
                    return t.emitEvent(e);
                  }),
                    (this.receiveBuffer = []),
                    this.sendBuffer.forEach(function (e) {
                      t.notifyOutgoingListeners(e), t.packet(e);
                    }),
                    (this.sendBuffer = []);
                },
              },
              {
                key: "ondisconnect",
                value: function () {
                  this.destroy(), this.onclose("io server disconnect");
                },
              },
              {
                key: "destroy",
                value: function () {
                  this.subs &&
                    (this.subs.forEach(function (t) {
                      return t();
                    }),
                    (this.subs = void 0)),
                    this.io._destroy(this);
                },
              },
              {
                key: "disconnect",
                value: function () {
                  return (
                    this.connected && this.packet({ type: _t.DISCONNECT }),
                    this.destroy(),
                    this.connected && this.onclose("io client disconnect"),
                    this
                  );
                },
              },
              {
                key: "close",
                value: function () {
                  return this.disconnect();
                },
              },
              {
                key: "compress",
                value: function (t) {
                  return (this.flags.compress = t), this;
                },
              },
              {
                key: "volatile",
                get: function () {
                  return (this.flags.volatile = !0), this;
                },
              },
              {
                key: "timeout",
                value: function (t) {
                  return (this.flags.timeout = t), this;
                },
              },
              {
                key: "onAny",
                value: function (t) {
                  return (
                    (this._anyListeners = this._anyListeners || []),
                    this._anyListeners.push(t),
                    this
                  );
                },
              },
              {
                key: "prependAny",
                value: function (t) {
                  return (
                    (this._anyListeners = this._anyListeners || []),
                    this._anyListeners.unshift(t),
                    this
                  );
                },
              },
              {
                key: "offAny",
                value: function (t) {
                  if (!this._anyListeners) return this;
                  if (t) {
                    for (var e = this._anyListeners, n = 0; n < e.length; n++)
                      if (t === e[n]) return e.splice(n, 1), this;
                  } else this._anyListeners = [];
                  return this;
                },
              },
              {
                key: "listenersAny",
                value: function () {
                  return this._anyListeners || [];
                },
              },
              {
                key: "onAnyOutgoing",
                value: function (t) {
                  return (
                    (this._anyOutgoingListeners =
                      this._anyOutgoingListeners || []),
                    this._anyOutgoingListeners.push(t),
                    this
                  );
                },
              },
              {
                key: "prependAnyOutgoing",
                value: function (t) {
                  return (
                    (this._anyOutgoingListeners =
                      this._anyOutgoingListeners || []),
                    this._anyOutgoingListeners.unshift(t),
                    this
                  );
                },
              },
              {
                key: "offAnyOutgoing",
                value: function (t) {
                  if (!this._anyOutgoingListeners) return this;
                  if (t) {
                    for (
                      var e = this._anyOutgoingListeners, n = 0;
                      n < e.length;
                      n++
                    )
                      if (t === e[n]) return e.splice(n, 1), this;
                  } else this._anyOutgoingListeners = [];
                  return this;
                },
              },
              {
                key: "listenersAnyOutgoing",
                value: function () {
                  return this._anyOutgoingListeners || [];
                },
              },
              {
                key: "notifyOutgoingListeners",
                value: function (t) {
                  if (
                    this._anyOutgoingListeners &&
                    this._anyOutgoingListeners.length
                  ) {
                    var e,
                      n = v(this._anyOutgoingListeners.slice());
                    try {
                      for (n.s(); !(e = n.n()).done; ) {
                        e.value.apply(this, t.data);
                      }
                    } catch (t) {
                      n.e(t);
                    } finally {
                      n.f();
                    }
                  }
                },
              },
            ]),
            i
          );
        })(x);
      function St(t) {
        (t = t || {}),
          (this.ms = t.min || 100),
          (this.max = t.max || 1e4),
          (this.factor = t.factor || 2),
          (this.jitter = t.jitter > 0 && t.jitter <= 1 ? t.jitter : 0),
          (this.attempts = 0);
      }
      (St.prototype.duration = function () {
        var t = this.ms * Math.pow(this.factor, this.attempts++);
        if (this.jitter) {
          var e = Math.random(),
            n = Math.floor(e * this.jitter * t);
          t = 0 == (1 & Math.floor(10 * e)) ? t - n : t + n;
        }
        return 0 | Math.min(t, this.max);
      }),
        (St.prototype.reset = function () {
          this.attempts = 0;
        }),
        (St.prototype.setMin = function (t) {
          this.ms = t;
        }),
        (St.prototype.setMax = function (t) {
          this.max = t;
        }),
        (St.prototype.setJitter = function (t) {
          this.jitter = t;
        });
      var Nt = (function (n) {
          o(s, n);
          var i = p(s);
          function s(n, r) {
            var o, a;
            e(this, s),
              ((o = i.call(this)).nsps = {}),
              (o.subs = []),
              n && "object" === t(n) && ((r = n), (n = void 0)),
              ((r = r || {}).path = r.path || "/socket.io"),
              (o.opts = r),
              I(f(o), r),
              o.reconnection(!1 !== r.reconnection),
              o.reconnectionAttempts(r.reconnectionAttempts || 1 / 0),
              o.reconnectionDelay(r.reconnectionDelay || 1e3),
              o.reconnectionDelayMax(r.reconnectionDelayMax || 5e3),
              o.randomizationFactor(
                null !== (a = r.randomizationFactor) && void 0 !== a ? a : 0.5
              ),
              (o.backoff = new St({
                min: o.reconnectionDelay(),
                max: o.reconnectionDelayMax(),
                jitter: o.randomizationFactor(),
              })),
              o.timeout(null == r.timeout ? 2e4 : r.timeout),
              (o._readyState = "closed"),
              (o.uri = n);
            var c = r.parser || Rt;
            return (
              (o.encoder = new c.Encoder()),
              (o.decoder = new c.Decoder()),
              (o._autoConnect = !1 !== r.autoConnect),
              o._autoConnect && o.open(),
              o
            );
          }
          return (
            r(s, [
              {
                key: "reconnection",
                value: function (t) {
                  return arguments.length
                    ? ((this._reconnection = !!t), this)
                    : this._reconnection;
                },
              },
              {
                key: "reconnectionAttempts",
                value: function (t) {
                  return void 0 === t
                    ? this._reconnectionAttempts
                    : ((this._reconnectionAttempts = t), this);
                },
              },
              {
                key: "reconnectionDelay",
                value: function (t) {
                  var e;
                  return void 0 === t
                    ? this._reconnectionDelay
                    : ((this._reconnectionDelay = t),
                      null === (e = this.backoff) ||
                        void 0 === e ||
                        e.setMin(t),
                      this);
                },
              },
              {
                key: "randomizationFactor",
                value: function (t) {
                  var e;
                  return void 0 === t
                    ? this._randomizationFactor
                    : ((this._randomizationFactor = t),
                      null === (e = this.backoff) ||
                        void 0 === e ||
                        e.setJitter(t),
                      this);
                },
              },
              {
                key: "reconnectionDelayMax",
                value: function (t) {
                  var e;
                  return void 0 === t
                    ? this._reconnectionDelayMax
                    : ((this._reconnectionDelayMax = t),
                      null === (e = this.backoff) ||
                        void 0 === e ||
                        e.setMax(t),
                      this);
                },
              },
              {
                key: "timeout",
                value: function (t) {
                  return arguments.length
                    ? ((this._timeout = t), this)
                    : this._timeout;
                },
              },
              {
                key: "maybeReconnectOnOpen",
                value: function () {
                  !this._reconnecting &&
                    this._reconnection &&
                    0 === this.backoff.attempts &&
                    this.reconnect();
                },
              },
              {
                key: "open",
                value: function (t) {
                  var e = this;
                  if (~this._readyState.indexOf("open")) return this;
                  this.engine = new ft(this.uri, this.opts);
                  var n = this.engine,
                    r = this;
                  (this._readyState = "opening"), (this.skipReconnect = !1);
                  var i = Tt(n, "open", function () {
                      r.onopen(), t && t();
                    }),
                    o = Tt(n, "error", function (n) {
                      r.cleanup(),
                        (r._readyState = "closed"),
                        e.emitReserved("error", n),
                        t ? t(n) : r.maybeReconnectOnOpen();
                    });
                  if (!1 !== this._timeout) {
                    var s = this._timeout;
                    0 === s && i();
                    var a = this.setTimeoutFn(function () {
                      i(), n.close(), n.emit("error", new Error("timeout"));
                    }, s);
                    this.opts.autoUnref && a.unref(),
                      this.subs.push(function () {
                        clearTimeout(a);
                      });
                  }
                  return this.subs.push(i), this.subs.push(o), this;
                },
              },
              {
                key: "connect",
                value: function (t) {
                  return this.open(t);
                },
              },
              {
                key: "onopen",
                value: function () {
                  this.cleanup(),
                    (this._readyState = "open"),
                    this.emitReserved("open");
                  var t = this.engine;
                  this.subs.push(
                    Tt(t, "ping", this.onping.bind(this)),
                    Tt(t, "data", this.ondata.bind(this)),
                    Tt(t, "error", this.onerror.bind(this)),
                    Tt(t, "close", this.onclose.bind(this)),
                    Tt(this.decoder, "decoded", this.ondecoded.bind(this))
                  );
                },
              },
              {
                key: "onping",
                value: function () {
                  this.emitReserved("ping");
                },
              },
              {
                key: "ondata",
                value: function (t) {
                  this.decoder.add(t);
                },
              },
              {
                key: "ondecoded",
                value: function (t) {
                  this.emitReserved("packet", t);
                },
              },
              {
                key: "onerror",
                value: function (t) {
                  this.emitReserved("error", t);
                },
              },
              {
                key: "socket",
                value: function (t, e) {
                  var n = this.nsps[t];
                  return n || ((n = new Bt(this, t, e)), (this.nsps[t] = n)), n;
                },
              },
              {
                key: "_destroy",
                value: function (t) {
                  for (
                    var e = 0, n = Object.keys(this.nsps);
                    e < n.length;
                    e++
                  ) {
                    var r = n[e];
                    if (this.nsps[r].active) return;
                  }
                  this._close();
                },
              },
              {
                key: "_packet",
                value: function (t) {
                  for (var e = this.encoder.encode(t), n = 0; n < e.length; n++)
                    this.engine.write(e[n], t.options);
                },
              },
              {
                key: "cleanup",
                value: function () {
                  this.subs.forEach(function (t) {
                    return t();
                  }),
                    (this.subs.length = 0),
                    this.decoder.destroy();
                },
              },
              {
                key: "_close",
                value: function () {
                  (this.skipReconnect = !0),
                    (this._reconnecting = !1),
                    this.onclose("forced close"),
                    this.engine && this.engine.close();
                },
              },
              {
                key: "disconnect",
                value: function () {
                  return this._close();
                },
              },
              {
                key: "onclose",
                value: function (t, e) {
                  this.cleanup(),
                    this.backoff.reset(),
                    (this._readyState = "closed"),
                    this.emitReserved("close", t, e),
                    this._reconnection &&
                      !this.skipReconnect &&
                      this.reconnect();
                },
              },
              {
                key: "reconnect",
                value: function () {
                  var t = this;
                  if (this._reconnecting || this.skipReconnect) return this;
                  var e = this;
                  if (this.backoff.attempts >= this._reconnectionAttempts)
                    this.backoff.reset(),
                      this.emitReserved("reconnect_failed"),
                      (this._reconnecting = !1);
                  else {
                    var n = this.backoff.duration();
                    this._reconnecting = !0;
                    var r = this.setTimeoutFn(function () {
                      e.skipReconnect ||
                        (t.emitReserved(
                          "reconnect_attempt",
                          e.backoff.attempts
                        ),
                        e.skipReconnect ||
                          e.open(function (n) {
                            n
                              ? ((e._reconnecting = !1),
                                e.reconnect(),
                                t.emitReserved("reconnect_error", n))
                              : e.onreconnect();
                          }));
                    }, n);
                    this.opts.autoUnref && r.unref(),
                      this.subs.push(function () {
                        clearTimeout(r);
                      });
                  }
                },
              },
              {
                key: "onreconnect",
                value: function () {
                  var t = this.backoff.attempts;
                  (this._reconnecting = !1),
                    this.backoff.reset(),
                    this.emitReserved("reconnect", t);
                },
              },
            ]),
            s
          );
        })(x),
        xt = {};
      function Lt(e, n) {
        "object" === t(e) && ((n = e), (e = void 0));
        var r,
          i = (function (t) {
            var e =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : "",
              n = arguments.length > 2 ? arguments[2] : void 0,
              r = t;
            (n = n || ("undefined" != typeof location && location)),
              null == t && (t = n.protocol + "//" + n.host),
              "string" == typeof t &&
                ("/" === t.charAt(0) &&
                  (t = "/" === t.charAt(1) ? n.protocol + t : n.host + t),
                /^(https?|wss?):\/\//.test(t) ||
                  (t = void 0 !== n ? n.protocol + "//" + t : "https://" + t),
                (r = ht(t))),
              r.port ||
                (/^(http|ws)$/.test(r.protocol)
                  ? (r.port = "80")
                  : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")),
              (r.path = r.path || "/");
            var i = -1 !== r.host.indexOf(":") ? "[" + r.host + "]" : r.host;
            return (
              (r.id = r.protocol + "://" + i + ":" + r.port + e),
              (r.href =
                r.protocol +
                "://" +
                i +
                (n && n.port === r.port ? "" : ":" + r.port)),
              r
            );
          })(e, (n = n || {}).path || "/socket.io"),
          o = i.source,
          s = i.id,
          a = i.path,
          c = xt[s] && a in xt[s].nsps;
        return (
          n.forceNew || n["force new connection"] || !1 === n.multiplex || c
            ? (r = new Nt(o, n))
            : (xt[s] || (xt[s] = new Nt(o, n)), (r = xt[s])),
          i.query && !n.query && (n.query = i.queryKey),
          r.socket(i.path, n)
        );
      }
      return i(Lt, { Manager: Nt, Socket: Bt, io: Lt, connect: Lt }), Lt;
    });
    //# sourceMappingURL=socket.io.min.js.map
  </script>
  <script>
    class Server {
      buttonDown(_, key) {
        if (!this.socket) {
          console.log(this.player, key);
          return;
        }
        this.socket.emit("chat message", {
          down: true,
          player: this.player,
          key,
        });
      }

      buttonUp(_, key) {
        if (!this.socket) {
          console.log(this.player, key);
          return;
        }
        this.socket.emit("chat message", {
          down: false,
          player: this.player,
          key,
        });
      }

      connect(url, name, player) {
        if (this.socket) {
          this.close();
        }
        this.socket = io(url);
        this.socket.emit("join room", name);
        this.player = player;
      }

      close() {
        this.socket.disconnect();
      }
    }

    class App {
      constructor() {
        /** @type { Object.<string,HTMLElement> } */
        this.components;
        registerProperties(
          this,
          "player",
          "players",
          "menus",
          "server",
          "directions",
          "last",
          "startPos"
        );
      }

      setPlayer(p) {
        this.player = p;
        if (this.player <= 0) {
          this.server.close();
        } else {
          this.server.connect(
            this.data.serverUrl,
            this.data.roomName,
            this.player
          );
        }
      }

      onkey(key, down) {
        if (down) {
          this.server.buttonDown(undefined, key);
        } else {
          this.server.buttonUp(undefined, key);
        }
      }

      dpadDown(e) {
        this.startPos = {
          x: e.clientX,
          y: e.clientY,
          dpad: e.currentTarget.children[0],
        };
        this.updateCurrentDirections(this.getCurrentDirections(e));
      }

      dpadUp(_) {
        const dpad = this.startPos?.dpad;
        this.startPos = undefined;
        this.updateCurrentDirections(new Set());
        if (dpad) {
          dpad.style.top = "70%";
          dpad.style.left = "30%";
        }
      }

      dpadMove(e) {
        const checkPeriod = 1000 / 60;
        this.last = this.last || Date.now();
        let now = Date.now();
        if (now - this.last < checkPeriod) {
          return;
        }
        this.updateCurrentDirections(this.getCurrentDirections(e, true));
        this.last = now;
      }

      getCurrentDirections(e, largeThread) {
        if (!this.startPos) {
          return new Set();
        }
        const thread = 10;
        const { x, y, dpad } = this.startPos;
        let dx = e.clientX - x;
        let dy = e.clientY - y;
        dpad.style.left = `${e.clientX}px`;
        dpad.style.top = `${e.clientY}px`;
        const directions = new Set();
        if (dx < -thread) {
          directions.add("left");
        }
        if (dx > thread) {
          directions.add("right");
        }
        if (dy < -thread) {
          directions.add("up");
        }
        if (dy > thread) {
          directions.add("down");
        }
        if (directions.size) {
          dx = Math.abs(dx);
          dy = Math.abs(dy);
          if (dx > 3 * dy) {
            directions.delete("up");
            directions.delete("down");
          }
          if (dy > 3 * dx) {
            directions.delete("left");
            directions.delete("right");
          }
        } else if (largeThread) {
          return this.directions;
        }
        return directions;
      }

      updateCurrentDirections(directions) {
        for (let key of this.directions) {
          if (!directions.has(key)) {
            this.onkey(key);
          }
        }
        for (let key of directions) {
          if (!this.directions.has(key)) {
            this.onkey(key, true);
          }
        }
        this.directions = directions;
      }

      start() {
        /** @type { { toast:(msg:string, timeout:number = 1000)=>Promise<any> } } */
        this.modal_ = this.components.modal.model;
        /** @type HTMLElement */
        this.dpad_ = this.components.dpad;
        this.players = [1, 2];
        this.player = 0;
        this.server = new Server();
        this.directions = [];
        this.menus = [
          { name: "关闭", up: () => this.setPlayer(0), down: () => {} },
          ...[
            ["上一页", "m-left"],
            ["下一页", "m-right"],
            ["上一项", "m-up"],
            ["下一项", "m-down"],
            ["最近", "m-select"],
            ["加载", "m-start"],
            ["选择", "select"],
            ["开始", "start"],
          ].map(([name, key]) => ({
            name,
            up: () => this.onkey(key),
            down: () => this.onkey(key, true),
          })),
        ];
      }
    }
  </script>
  <template id="app-main" view-model="App">
    <div id="app">
      <div class="controller" if.="player">
        <div
          id="directions"
          onpointermove.="dpadMove($event)"
          onpointerdown.="dpadDown($event)"
          onpointerup.="dpadUp($event)"
          onpointerleave.="dpadUp($event)"
          onpointercancel.="dpadUp($event)"
        >
          <div id="dpad">
            <div></div>
          </div>
        </div>
        <div class="menus">
          <div
            class="menu"
            for.="let m of menus"
            onpointerdown.="m.down()"
            onpointerup.="m.up()"
            onpointercancel.="m.up()"
          >
            <span inner-text$.="m.name"></span>
          </div>
        </div>
        <div class="buttons">
          <div
            class="button-a_b"
            onpointerdown.="onkey('a_b', true)"
            onpointerleave.="onkey('a_b')"
            onpointercancel.="onkey('a_b')"
          ></div>
          <div class="buttons-single">
            <div
              class="button-b"
              onpointerdown.="onkey('b', true)"
              onpointerleave.="onkey('b')"
              onpointercancel.="onkey('b')"
            ></div>
            <div
              class="button-a"
              onpointerdown.="onkey('a', true)"
              onpointerleave.="onkey('a')"
              onpointercancel.="onkey('a')"
            ></div>
          </div>
        </div>
      </div>
      <div class="players" if.="!player">
        <div class="player" for.="let p of players">
          <span inner-text$.="'玩家' + p" onclick.="setPlayer(p)"></span>
        </div>
      </div>
    </div>
    <modal-panel id="modal"></modal-panel>
    <style>
      :host {
        display: block;
      }

      .players {
        display: flex;
        height: 100vh;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }

      .player {
        padding: 10px;
        background: blueviolet;
        display: inline-block;
        margin: 20px 0;
        font-size: larger;
        width: 6em;
        text-align: center;
        border-radius: 10px;
        filter: drop-shadow(2px 4px 6px);
      }

      .player:hover {
        filter: drop-shadow(1px 1px 2px);
      }

      .controller {
        display: flex;
        height: 100vh;
      }

      #directions {
        flex: 1;
        position: relative;
        background: #fff2;
      }

      #dpad,
      #dpad > div {
        position: absolute;
        transform: translate(-50%, -50%);
        border-radius: 100%;
      }

      #dpad {
        left: 30%;
        top: 70%;
        width: 120px;
        height: 120px;
        background: #fff8;
        filter: drop-shadow(2px 4px 6px black);
      }

      #dpad > div {
        top: 50%;
        left: 50%;
        width: 50%;
        height: 50%;
        background: #fff;
      }

      .buttons {
        flex: 1;
        display: flex;
      }

      .buttons-single {
        flex: 3;
        display: flex;
        flex-direction: column;
      }

      .button-a_b {
        flex: 2;
        margin-right: 2px;
      }

      .button-a {
        flex: 1;
        margin-top: 1px;
      }

      .button-b {
        flex: 1;
        margin-bottom: 1px;
      }

      .button-a_b,
      .button-a,
      .button-b {
        background: #fff2;
      }

      .button-a_b:hover,
      .button-a:hover,
      .button-b:hover {
        background: #fff4;
      }

      .menus {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        margin: 2em 0;
      }

      .menu {
        margin: 0 5px;
        border-radius: 5px;
        background: #cccc;
        color: #3d3d3d;
        font-size: small;
        padding: 5px 10px;
        text-align: center;
      }

      * {
        user-select: none !important;
        -webkit-user-select: none !important;
      }
    </style>
  </template>
  <style>
    body {
      background: black;
      touch-action: none;
      color: #ccc;
    }
  </style>
  <script>
    window.appData = window.appData || {
      serverUrl: "ws://192.168.3.100:9999",
      roomName: "nes remote control",
    };
  </script>

  <meta
    name="viewport"
    content="width=device-width, maximum-scale=1.0,user-scalable=no, initial-scale=1"
  />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="transparent" />
  <script>
    const { registerElement, registerProperties } = (() => {
      const evalInContext = (exp, context) => {
        return function () {
          with (this) {
            try {
              return eval(`(${exp})`);
            } catch (e) {
              return;
            }
          }
        }.call(context);
      };

      const onprop = (exp, context, listener) => {
        const tokens = exp.split(".");
        if (tokens[1]) {
          if (context.tmpCtxName === tokens[0]) {
            const tmpCtx = context[context.tmpCtxName];
            if (tmpCtx && tmpCtx.on) {
              tmpCtx.on(tokens[1], listener);
            }
          }
        } else {
          context.on && context.on(tokens[0], listener);
        }
      };

      const bindingForInstruction = (/**@type HTMLElement */ element) => {
        let forExp = element.getAttribute("for.");
        const match = forExp.match(
          /^\s*(((let|const|of)\s+)?(\w+)\s+(of|in)\s+)?\s*([\w.]+)\s*$/
        );
        if (!match || !match[6]) {
          throw new Error("Invalid for Expression");
        }
        const collectionName = match[6];
        const of_in = match[5] || "of";
        let varName = match[4];
        let forHead;
        if (varName) {
          forHead = `for(const ${varName} ${of_in} ${collectionName})`;
        } else {
          varName = "$$i";
          forHead = `for(const ${varName} of ${collectionName})`;
        }
        const comment = document.createComment(element.outerHTML);
        const parent = element.parentElement;
        parent.insertBefore(comment, element);
        element.remove();
        /**@type Map<any, HTMLElement> */
        let items = new Map();
        /**@type Map<any, HTMLElement> */
        let newItems = new Map();
        let idx = 0;
        let allRemoved = false;
        const update = () => {
          (function ($$forEach) {
            newItems = new Map();
            idx = 0;
            allRemoved = false;
            with (this) {
              eval(`
          if (this.${collectionName}) {
            ${forHead}{
              $$forEach(${varName})
              }
          }`);
            }
            for (const [_, { item }] of items) {
              item.remove();
            }
            items = newItems;
          }.call(element.context, ($$i) => {
            /**@type HTMLElement */
            let item;
            if (items.has($$i)) {
              const pair = items.get($$i);
              item = pair.item;
              if (!allRemoved && idx !== pair.idx) {
                console.log("removed");
                for (const [_, { item }] of items) {
                  item.remove();
                }
                allRemoved = true;
              }
              items.delete($$i);
            } else {
              item = element.cloneNode(true);
              item.removeAttribute("id");
              item.removeAttribute("for.");
              if (item.updateModel) {
                item.model = $$i;
              } else {
                item.modelBeforeInit = $$i;
              }
              const context = Object.create(element.context);
              context[varName] = $$i;
              context.tmpCtxName = varName;
              item.context = context;
            }
            parent.insertBefore(item, comment);
            newItems.set($$i, { idx, item });
            binding(item);
            idx++;
          }));
        };
        update();
        let lastContext = element.context;
        comment.updateWhenModelChange = () => {
          if (lastContext === element.context) {
            return;
          }
          lastContext = element.context;
          update();
        };
        onprop(collectionName, element.context, update);
        return {};
      };

      const bindingIfInstruction = (/**@type HTMLElement */ element) => {
        let ifExp = element.getAttribute("if.");
        const comment = document.createComment(element.outerHTML);
        const parent = element.parentElement;
        parent.insertBefore(comment, element);
        element.remove();
        let item;
        const update = () => {
          const value = evalInContext(ifExp, element.context);
          if (value) {
            if (item) {
              return;
            }
            item = element.cloneNode(true);
            item.removeAttribute("if.");
            parent.insertBefore(item, comment);
            item.context = element.context;
            binding(item);
          } else if (item) {
            item.remove();
            item = null;
          }
        };
        update();
        let lastContext = element.context;
        comment.updateWhenModelChange = () => {
          if (lastContext === element.context) {
            return;
          }
          lastContext = element.context;
          update();
        };
        for (const exp of getPropsFromExp(ifExp)) {
          onprop(exp, element.context, update);
        }
        return {};
      };

      const getPropNameFromBindingAttr = (attr) => {
        return attr.replace(/-(\w)/g, (_, c) => c.toUpperCase());
      };

      const getPropsFromExp = (exp) => {
        return exp.match(/[a-zA-Z0-9_$.]+/g) || [];
      };

      const bindingAttrs = (/**@type HTMLElement */ element) => {
        if (element.hasAttribute("for.")) {
          return bindingForInstruction(element);
        }
        if (element.hasAttribute("if.")) {
          return bindingIfInstruction(element);
        }
        if (element.updateWhenModelChange) {
          element.updateWhenModelChange();
          return element;
        }
        const bindingAttrs = element
          .getAttributeNames()
          .filter((p) => p.endsWith("."));
        for (const prop of bindingAttrs) {
          const $$exp = element.getAttribute(prop);
          const effectedAttr = prop
            .slice(0, -".".length)
            .split(",")
            .map((a) => a.trim())
            .filter((a) => a);

          if (effectedAttr.some((a) => a.startsWith("on"))) {
            const value = `(function($event){with(this){${$$exp}}}).call(event.target.context, event)`;
            for (const ea of effectedAttr) {
              if (ea.endsWith("$")) {
                element.setAttribute(
                  ea.slice(0, -1),
                  "event.stopPropagation();" + value
                );
              } else {
                element.setAttribute(ea, value);
              }
            }
            continue;
          }
          const update = () => {
            const value = evalInContext($$exp, element.context);
            for (const ea of effectedAttr) {
              if (ea === "model") {
                if (element.updateModel) {
                  element.updateModel(value);
                } else {
                  element.modelBeforeInit = value;
                }
                continue;
              }
              if (ea.startsWith("class-")) {
                const className = ea.slice("class-".length);
                if (value) {
                  element.classList.add(className);
                } else {
                  element.classList.remove(className);
                }
                continue;
              } else if (ea.startsWith("style-")) {
                const prop = ea.slice("style-".length, -1);
                element.style.setProperty(prop, value);
                continue;
              }
              if (ea.endsWith("$")) {
                let prop = getPropNameFromBindingAttr(ea.slice(0, -1));
                switch (prop) {
                  case "innerHtml":
                    prop = "innerHTML";
                    break;
                }
                element[prop] = value;
                continue;
              }
              if (value === undefined || value === null) {
                element.removeAttribute(ea);
              } else if (element[ea] !== value) {
                element.setAttribute(ea, value);
              }
            }
          };
          update();
          for (const exp of getPropsFromExp($$exp)) {
            onprop(exp, element.context, update);
          }
        }
        return element;
      };

      const binding = (/**@type HTMLElement */ element) => {
        /**@type { Object.<string,HTMLElement> } */
        const components = element.context.components;
        if (element.hasAttribute) {
          const handler = bindingAttrs(element);
          //collect ids
          if (element.hasAttribute("id")) {
            components[element.getAttribute("id")] = handler;
          }
          if (handler !== element) {
            return;
          }
        }
        for (const child of [...element.children]) {
          if (
            child.context == element.context ||
            (child.context &&
              Object.getPrototypeOf(child.context) === element.context)
          ) {
          } else {
            child.context = element.context;
          }
          binding(child);
        }
      };

      const getNameFromTagName = (tagName) => {
        return tagName.replace(/(?:^|-)(\w)/g, (_, c) => c.toUpperCase());
      };

      const registerProperties = (obj, ...props) => {
        if (!obj.define) {
          addPropChange(obj);
        }
        props.forEach((prop) => {
          let propValue;
          let [propName, handler] =
            prop instanceof Array ? prop : [prop, undefined];
          Object.defineProperty(obj, propName, {
            get() {
              return propValue;
            },
            set(newValue) {
              const oldValue = propValue;
              propValue = newValue;
              obj.raise(propName, newValue, oldValue);
              handler?.(newValue, oldValue);
            },
          });
        });
      };

      const addPropChange = (/**@type { Object } */ obj) => {
        /**@type Map<string, Set<{(newValue, oldValue):any}>> */
        const listeners = new Map();
        obj.define = (...props) => registerProperties(obj, ...props);
        obj.on = (/**@type string */ prop, listener) => {
          if (!listeners.has(prop)) {
            listeners.set(prop, new Set());
          }
          listeners.get(prop).add(listener);
        };
        obj.off = (prop, listener) => {
          if (!listeners.has(prop)) {
            return;
          }
          listeners.get(prop).delete(listener);
        };
        obj.raise = (prop, newValue, oldValue) => {
          if (!listeners.has(prop)) {
            return;
          }
          for (const listener of listeners.get(prop)) {
            listener(newValue, oldValue);
          }
        };
      };

      const registerElement = (tagName, /**@type { string } */ constructor) => {
        const elementClassName = `HTML${
          constructor || getNameFromTagName(tagName)
        }Element`;
        constructor = constructor || "Object";
        eval(`
    class ${elementClassName} extends HTMLElement{
      constructor(){
        super()
        const shadow = this.attachShadow({mode:'open'})
        const template = document.getElementById('${tagName}')
        if(!template || template.tagName !== 'TEMPLATE' ){
          throw new Error('Define Template')
        }
        this.template_ = template
        this.shadow_ = shadow
        this.model_ = new ${constructor}()
        this.model_.components = { host: this.shadow_ }
        if(this.context && this.hasAttribute('model.')){
          const modeExp = this.getAttribute('model.')
          this.model = evalInContext(modeExp, this.context)
        }else if(this.modelBeforeInit){
          this.model = this.modelBeforeInit
        }else{
          this.model =  {}
        }
      }

      rebuildView(){
        this.shadow_.innerHTML = ''
        const instance = document.importNode(this.template_.content, true)
        this.shadow_.appendChild(instance)
      }
  
      get model(){
        return this.model_
      }
  
      set model(value){
        //combine code behind with model
        Object.assign(this.model_, value)
        this.shadow_.context = this.model_ 
        this.rebuildView()
      }
  
      updateModel(value){
        this.model = value
        this.connectedCallback()
      }
      
      connectedCallback(){
        binding(this.shadow_)
        if(this.model_.launch){
          this.model_.launch()
        } 
      }
    }
    customElements.define('${tagName}', ${elementClassName})
    `);
      };
      return { registerElement, registerProperties };
    })();

    const sleep = (timeout) =>
      new Promise((resolve) => setTimeout(resolve, timeout));

    class AppBase {
      async launch() {
        this.storage = this.initStorage_();
        this.data = await this.initData(window.appData);
        window.app = this;
        await this.start();
      }

      async registerStorageProperties(...props) {
        if (!this.storage) {
          return;
        }
        let asyncTimeout = 50;
        const bgTimeout = 200;
        for (const [prop, defaultValue, onchange] of props) {
          let propValue;
          let valueModified = false;
          let successLoadFromStorage = false;
          let loadFunc;
          let bgLoad = false;
          const mergeValue = (savedValue) => {
            if (successLoadFromStorage) {
              return;
            }
            successLoadFromStorage = true;
            if (!valueModified) {
              valueModified = true;
              propValue = savedValue;
            } else {
              // merge strategy
              propValue = savedValue;
            }
            if (bgLoad && onchange) {
              onchange();
            }
          };
          loadFunc = async () => {
            const jsonStr = await this.storage.getItem(prop);
            let savedValue;
            if (!jsonStr) {
              savedValue = defaultValue;
            } else {
              try {
                savedValue = JSON.parse(jsonStr);
              } catch {
                savedValue = defaultValue;
              }
            }
            mergeValue(savedValue);
          };
          const tryLoad = async () => {
            bgLoad = true;
            const func = loadFunc;
            loadFunc = null;
            await Promise.race([
              func(),
              sleep(bgTimeout).then(() => {
                if (!successLoadFromStorage) {
                  loadFunc = func;
                }
              }),
            ]);
          };
          await Promise.race([
            loadFunc(),
            sleep(asyncTimeout).then(() => {
              if (!valueModified) {
                propValue = defaultValue;
                valueModified = true;
                asyncTimeout = 0;
              }
            }),
          ]);
          Object.defineProperty(this, prop, {
            get() {
              if (loadFunc) {
                tryLoad();
              }
              return propValue;
            },
            set(newValue) {
              propValue = newValue;
              if (successLoadFromStorage) {
                this.storage.setItem(prop, JSON.stringify(propValue));
              }
            },
          });
        }
      }

      initStorage_() {
        if (window.$localStorage) {
          return window.$localStorage;
        }
        try {
          const s = window.localStorage;
          return s;
        } catch {
          return {
            getItem: () => "",
            setItem: () => true,
          };
        }
      }

      async initData(data) {
        return data;
      }

      async start() {
        console.log("start");
      }

      async pause() {
        console.log("pause");
      }

      async resume() {
        console.log("pause");
      }

      async stop() {
        console.log("stop");
      }
    }

    window.onload = async () => {
      Object.setPrototypeOf(App.prototype, AppBase.prototype);
      for (const template of document.querySelectorAll(
        "template[id][view-model]"
      )) {
        const tagName = template.getAttribute("id");
        if (!tagName) {
          continue;
        }
        const codeBehind = template.getAttribute("view-model");
        registerElement(tagName, codeBehind);
      }
    };
  </script>

  <style>
    html,
    body {
      height: 100%;
      margin: 0;
    }
  </style>

  <body>
    <app-main></app-main>

    <template id="h-stack" view-model>
      <slot></slot>
      <style>
        :host {
          display: flex;
          flex-direction: row;
        }
      </style>
    </template>
    <template id="v-stack" view-model>
      <slot></slot>
      <style>
        :host {
          display: flex;
          flex-direction: column;
        }
      </style>
    </template>
    <template id="hv-stack" view-model>
      <slot></slot>
      <style>
        :host {
          display: flex;
          flex-direction: column;
        }
        @media (orientation: landscape) {
          :host {
            flex-direction: row;
          }
        }
      </style>
    </template>

    <template id="h-spacer" view-model>
      <slot></slot>
      <style>
        :host {
          flex: 1;
          display: flex;
        }
      </style>
    </template>

    <template id="h-text" view-model>
      <span inner-text$.="content"></span>
      <style>
        :host {
          flex: 1;
          display: flex;
          align-items: center;
          place-content: center;
        }
      </style>
    </template>

    <template id="play-button" view-model>
      <span id="btnPlay" class="play-button" class-pause.="isPlaying"></span>
      <style>
        :host {
          display: block;
          border-radius: 5px;
          padding: 3px 10px;
          background-color: #fff4;
        }
        .play-button {
          display: block;
          width: 100%;
          height: 100%;
          background-color: var(--color);
          clip-path: polygon(25% 10%, 25% 90%, 95% 50%, 25% 10%);
          transition: 200ms all ease-in-out;
        }
        .play-button.pause {
          clip-path: polygon(
            60% 50%,
            20% 20%,
            20% 80%,
            60% 50%,
            60% 80%,
            80% 80%,
            80% 20%,
            60% 20%
          );
        }
      </style>
    </template>

    <template id="menu-bar" view-model>
      <h-stack>
        <div class-hidden.="!item.show" class="menu-item" for.="item of menus">
          <span inner-text$.="item.name" onclick.="item.onclick()"></span>
        </div>
      </h-stack>
      <style>
        :host {
          display: block;
        }
        h-stack {
          overflow: hidden;
        }
        .menu-item {
          margin: 5px;
          background-color: var(--menu-background-color);
          border-radius: 4px;
          padding: 2px 5px;
          color: var(--menu-color);
          display: flex;
          justify-content: center;
          flex: 1;
        }
        .menu-item > span {
          display: block;
          text-overflow: ellipsis;
          white-space: pre;
          overflow: hidden;
          max-width: 6em;
        }
        .hidden {
          display: none;
        }
      </style>
    </template>

    <script>
      class MenuItem {
        constructor(name = "", onclick = null, show = true) {
          registerProperties(this, "name", "show");
          this.name = name;
          this.show = show;
          this.onclick = onclick;
        }
      }
    </script>

    <template id="modal-panel" view-model="Modal">
      <span class-hidden.="!toastMessage" inner-text$.="toastMessage"></span>
      <style>
        .hidden {
          /* left: -100%; */
          /* transition: ease-in-out 0.05s left; */
          display: none;
        }
        span {
          color: var(--toast-color, #eee);
          background-color: var(--toast-background-color, #0008);
          position: fixed;
          bottom: 0;
          margin: 20px auto;
          left: 50%;
          transform: translate(-50%, 0);
          padding: 5px 20px;
          border-radius: 4px;
          text-align: center;
          backdrop-filter: blur(5px);
        }
      </style>
    </template>
    <script>
      class Modal {
        constructor() {
          /**@type { Object.<string,HTMLElement> } */
          this.components;
          /**@type { Storage | {  } } */
          this.storage;
          registerProperties(this, "toastMessage");
        }
        toast(/**@string */ msg, /**@type number */ timeout = 1000) {
          return new Promise((resolve) => {
            this.toastMessage = msg;
            setTimeout(() => {
              this.toastMessage = null;
              resolve();
            }, timeout);
          });
        }
      }
    </script>
    <template id="pop-up" view-model="Popup">
      <div class="popup">
        <slot></slot>
      </div>
      <style>
        :host {
          display: block;
          position: relative;
          left: 0;
          top: 0;
          bottom: 0;
          right: 0;
          position: fixed;
          background: #0008;
          backdrop-filter: blur(5px);
        }
        .popup {
          max-width: 99%;
          max-height: 99%;
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
        }
      </style>
    </template>
    <script>
      class Popup {}
    </script>
  </body>
</html>
